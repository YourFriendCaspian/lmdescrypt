#!/bin/bash
set +o xtrace +o verbose -o errexit -o errtrace

############################################################################
#
#  lmdescrypt 0.88
#
# This script installs Linux Mint Debian Edition i686 or amd64, version 201403,
#  or Linux Mint Debian Edition version 2 (201504), or
#  regular Linux Mint 17.1, 17.2, 17.3 or 18 to be:
#  Fully LUKS encrypted, with lvm2 volumes of root and swap (and optionally: data)
# Only works with non-UEFI so far!
#
# Github page: https://github.com/pepa65/lmdescrypt
#
# See forum topic: http://forums.linuxmint.com/viewtopic.php?f=189&t=132520
# Shortlink to download the script: http://j.mp/lmdescrypt
# Questions? Email solusos@passchier.net or post an Issue on the github page.
#
############################################################################
### CONTENTS:
## - INSTRUCTIONS for preparation and use
## - SETTINGS to be adjusted
## - FUNCTIONS
## - INIT
## - MAIN
############################################################################

############################################################################
#### INSTRUCTIONS
############################################################################
##
### 1. Boot the Live environment
##
### 2. Open a Terminal (Menu/Terminal of Ctrl-Alt-T) and enter:
##  wget j.mp/lmdescrypt
##  chmod +x lmdescrypt
##
### 3. If needed, adapt the SETTINGS section:
##  nano lmdescrypt
##
### 4. Partition the drive, for instance (taking up all space):
##
##  sudo fdisk /dev/sda
##  o [Enter]
##  n [Enter]
##    [Enter]
##    [Enter]
##    [Enter]
##  +500M [Enter]
##  n [Enter]
##    [Enter]
##    [Enter]
##    [Enter]
##    [Enter]
##  w [Enter]
##
## (This is making a 500 MB boot partition, and giving the rest to the encrypted lvm2)
##
### 5. Start the script:
##
##  sudo ./lmdescrypt
##
### 6. Answer the questions as they come up:
## - password for encryption (twice the same)
## - password for decryption (same again)
## Then after a wait for all the preparations to have happened:
## - password for user, and some irrelevant info
## - about the keyboard
## - about the timezone
##
### And that's it!
##
##
### Installing into a pre-existing environment
## Using a pre-existing boot-partition, LUKS partition and LVM Logical Volumes is entirely supported.
## The options are to USE (or not), to CREATE (or not), and to FORMAT (or not) these devices.
##
############################################################################

############################################################################
#### SETTINGS
############################################################################
## Review all settings below

### Adjust if needed (not needed if following the suggested partitioning)
## Specify the partitions you created by any valid device path, like:
## /dev/disk/by-label/...  /dev/...  /dev/disk/by-id/...
boot_part=/dev/sda1
crypt_part=/dev/sda2

## Adjust only if you already have a LUKS encrypted partition that you want to wipe and start from scratch
### Wipe the crypt-partition before setup, even if already set up, if 1:
force_reencrypt=0

## No strict need to adjust; only takes effect if force_reencrypt (above) is 1
## WARNING: Putting 1 here will take a LONG time (depending on the size), let it run overnight!
### Check for bad blocks and fill with pseudorandom data if 1:
force_random=0

## No need to adjust unless re-using existing volumes
## The crypt_label will also be used as the Volume Group name
## If a Volume Group or Logical Volume with this name EXISTS, IT WILL BE USED!
## The data_label will also be the name of the mountpoint
## If empty, the default NAME (in NAME_label) will be used
### Filesystem labels (no spaces):
crypt_label=
boot_label=
root_label=
swap_label=
data_label=

## Don't allot more space than available, and at least 6GB for root
## Specify lvm2 volume sizes in gigabytes (G) or megabytes (M), no decimal points or spaces, like: 10G or 200M
## - if empty (only for swap or data) it will NOT BE USED
## - if EXISTING then the Logical Volume will need to exist already
##   (and so should the Volume Group then!)
## - if REST (only for root or data, not both) then the rest of the available space will be used
## - DEFAULT (only for swap) means 40% of RAM size (/sys/power/image_size)
##   (See: https://www.kernel.org/doc/Documentation/power/interface.txt)
### Partition usage & sizes:
root_size=REST
swap_size=DEFAULT
data_size=

## Adjust if re-using preexisting boot or data volumes!
## Fill in the desired filesystem-type, empty means it will NOT BE FORMATTED!
##  (pre-existing filesystem will be kept!)
## Supported for boot and root: ext2 ext3 ext4 reiserfs xfs, for swap: swap
## Supported for data: ext2 ext3 ext4 hfs hfsplus jfs minix msdos ntfs reiserfs vfat xfs
### Filesystems:
boot_fs=ext2
root_fs=ext4
swap_fs=swap
data_fs=

## Adjust only if installing to a secondary drive, or needing to keep old bootloader
### Device to install grub (by any valid device path):
grub_device=/dev/sda

## Adjust if you require another encryption scheme
## Find the speeds on your hardware by: cryptsetup benchmark (and choose accordingly)
### Parameters for cryptsetup luksFormat:
cryptopts='-c aes-xts-plain -s 512 -h sha512'

## Adjust according to preference
### Username and hostname (no spaces):
username=me
hostname=mine

## Adjust according to preference
### Extra packages to be installed (in between the single quotes, seperated by space):
packages=''

############################################################################
#### FUNCTIONS
############################################################################

Exit(){	echo -e "  ERROR: $1\n  ABORTING"; exit 1;}

Mkfs(){ ## $1=fs $2=label $3=dev $4=kind
	case $1 in
		hfs|hfsplus|jfs|minix|msdos|vfat|ntfs) ! [[ $4 = data ]] && Exit "A $1 filesystem is not supported on $4" ;;&
		## Continue even if the above pattern matched
		ext2|ext3|ext4) mkfs.$1 -F -L "$2" "$3" ;;
		hfs) mkfs.$1 -h -v "$2" "$3" ;;
		hfsplus) mkfs.$1 -J -v "$2" "$3" ;;
		jfs) mkfs.$1 -q -L "$2" "$3" ;;
		minix) mkfs.$1 "$3" ;;
		msdos|vfat) mkfs.$1 -n "$2" "$3" ;;
		ntfs) mkfs.$1 -f -F -U -L "$2" "$3" ;;
		reiserfs) mkfs.$1 -ffl "$2" "$3" ;;
		xfs) mkfs.$1 -f -L "$2" "$3" ;;
		*) Exit "Unsupported filesystem $1 for $4-device $3 with label $2" ;;
	esac
}

############################################################################
#### INIT
############################################################################

cself=$BASH_SOURCE
rself=$(readlink -e $cself)
self=$(basename $cself)
((EUID)) && Exit "This script only works when run with root privileges, like: sudo $BASH_SOURCE"
[[ -f /sys/firmware/efi ]] && Exit "This script doesn't yet work for UEFI installs!"

## The chroot invocation
if [[ $1 = inside ]]
then  ## Inside the chroot of the new system on /target
		((lmde)) && [[ -d /lib/live/mount ]] && Exit "Not in chroot, can't call 'inside': $self $*"
		! ((lmde)) && [[ -d /cdrom ]] && Exit "Not in chroot, can't call 'inside': $self $*"
		username=$2
		grub_device=$3
		lmde=$4
		shift 4
		packages=$*
		mount -t sysfs sys /sys
		mount -t proc proc /proc
		mount -t devpts pts /dev/pts
		export PS1='\[\033[01;33m\]\w \[\033[01;32m\]\$ \[\033[00m\]'
		locale-gen --purge $LANGUAGE
		useradd -ms /bin/bash $username
		pw="" pwa="" setting_pw=1
		while ((setting_pw))
		do
			pw=$(/lib/cryptsetup/askpass "Enter password for user $username: ")
			echo
			if [[ "$pw" ]]
			then
				pwa=$(/lib/cryptsetup/askpass "Enter the same password again: ")
				echo
				[[ "$pw" = "$pwa" ]] && setting_pw=0 || echo -e "Passwords not the same, do it again!\n"
			else
				echo "Password can't be empty!"
			fi
		done
		pwa=$(printf %${#pw}s)
		chpw="$username:$pw"
		((lmde)) && chpw="$chpw"$'\n'"root:$pw"
		pw=$pwa
		chpasswd <<<"$chpw"
		chpw=$(printf %${#chpw}s)
		addgroup $username sudo
		((lmde)) || passwd -l root
		dpkg --configure -a
		dpkg-reconfigure keyboard-configuration
		dpkg-reconfigure tzdata
		apt-get update
		rm -f /initrd.img
		[[ "$packages" ]] && apt-get --yes --force-yes --reinstall install $packages
		((lmde)) && apt-get --yes purge '^live-.*'
		update-grub
		grub-install --recheck --force "$grub_device"
		gconftool-2 --set /apps/gksu/sudo-mode --type bool true
		((lmde)) && rm -rvf /lib/live
		umount /dev/pts
		umount /proc
		umount /sys
		exit 0
fi

## Check existence of mandatory devices
[[ -w "$boot_part" ]] || Exit "Boot device does not exist or is not writable: '$boot_part'"
[[ -w "$crypt_part" ]] || Exit "Crypt device does not exist or is not writable: '$crypt_part'"
[[ -w "$grub_device" ]] || Exit "Grub device does not exist or is not writable: '$grub_device'"

## Check names and labels
[[ $username =~ ^[a-z_][a-z0-9_]*$ ]] || Exit "Illegal format for username: '$username'"
[[ $hostname =~ ^[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]$ ]] || Exit "Illegal format for hostname: '$hostname'"
[[ $crypt_label ]] || crypt_label=crypt
[[ $crypt_label = "${crypt_label/ /}" ]] || Exit "Label crypt_label contains spaces: '$crypt_label'"
[[ -e /dev/$crypt_label ]] && Exit "Device /dev/$crypt_label exists, Volume Group name $crypt_label unavailable"
[[ $boot_label ]] || boot_label=boot
[[ $boot_label = "${boot_label/ /}" ]] || Exit "Label boot_label contains spaces: '$boot_label'"
[[ $root_label ]] || root_label=root
[[ $root_label = "${root_label/ /}" ]] || Exit "Label root_label contains spaces: '$root_label'"
[[ $swap_label ]] || swap_label=swap
[[ $swap_label = "${swap_label/ /}" ]] || Exit "Label swap_label contains spaces: '$swap_label'"
[[ $data_label ]] || data_label=data
[[ $data_label = "${data_label/ /}" ]] || Exit "Label data_label contains spaces: '$data_label'"

## Determine root and data partition usage & size
[[ $root_size ]] && ! [[ $root_size = REST ]] && ! [[ $root_size = EXISTING ]] \
		&& ! [[ $root_size =~ [1-9][0-9]*[MG] ]] \
		&& Exit "Invalid format root_size: '$root_size'"
if [[ $data_size = REST ]]
then
	[[ $root_size = REST ]] && Exit "Settings data_size and root_size can't both be REST"
	lvm_data='-l 100%FREE -Zy'
else
	if [[ $data_size ]]
	then  ## not REST but not empty
		! [[ $data_size =~ [1-9][0-9]*[MG] ]] \
				&& Exit "Invalid format data_size: '$data_size'"
		lvm_data="-L $data_size -Zy"
	fi
fi

## Set swap size
if [[ $swap_size = DEFAULT ]]
then
	lvm_swap="-L $(cat /sys/power/image_size)B -Cy -Zy"
else
	if ! [[ $swap_size = EXISTING ]]
	then
		[[ $swap_size ]] && ! [[ $swap_size =~ [1-9][0-9]*[MG] ]] \
				&& Exit "Invalid format swap_size: $swap_size"
		lvm_swap="-L $swap_size -Cy -Zy"
	fi
fi

packages+=" linux-image-$(uname -r)"

rofsde='/lib/live/mount/rootfs/filesystem.squashfs'
rofslm='/rofs'
if [[ -d /lib/live ]]
then  ## Debian Edition
	lmde=1
	rofs=$rofsde
else  ## regular Mint
	lmde=0
	rofs=$rofslm
fi


############################################################################
#### MAIN
############################################################################

## Encrypt
if ((force_reencrypt))
then
	((force_random)) && badblocks -c 10240 -s -w -t random -v "$crypt_part"
	cryptsetup luksFormat $cryptopts "$crypt_part"
else
	cryptsetup isLuks "$crypt_part" && echo -e "\n  $crypt_part is already formatted, reencryption not forced" \
			|| cryptsetup luksFormat $cryptopts "$crypt_part"
fi

## Decrypt if not yet mapped
crypt_dev="/dev/mapper/$crypt_label"
[[ -b "$crypt_dev" ]] || cryptsetup luksOpen "$crypt_part" $crypt_label
crypt_uuid=$(blkid -s UUID -o value "$crypt_part")

## Make lvm2 volumes if not there yet and format if wanted
[[ "  $crypt_label" = "$(vgs --noheadings -o vg_name)" ]] || vgcreate -Zy $crypt_label $crypt_dev
vgchange --refresh
root_dev="/dev/$crypt_label/$root_label"
data_dev="/dev/$crypt_label/$data_label"
swap_dev="/dev/$crypt_label/$swap_label"

## Create & format swap if wanted
if [[ $swap_size ]]
then
	! [[ -h $swap_dev ]] && lvcreate $lvm_swap -n $swap_label $crypt_label
	[[ $swap_fs = swap ]] && mkswap -f -L $swap_label "$swap_dev"
fi

! [[ $root_size = REST ]] && ! [[ -h $root_dev ]] && lvcreate -L $root_size -Zy -n $root_label $crypt_label
if [[ $data_size ]]
then  ## Create if it doesn't exist and format if required
	if [[ -h $root_dev ]]
	then
		data_fs=$(lsblk "$data_dev" -no FSTYPE 2>/dev/null)
		! [[ $data_fs ]] \
				&& Exit "Data volume is not formatted; format first or fill in 'data_fs'"
	else
		! [[ $data_fs ]] && Exit "Can't create data partition without format"
		lvcreate $lvm_data -n $data_label $crypt_label
		Mkfs "$data_fs" "$data_label" "$data_dev" data
	fi
fi
[[ $root_size = REST ]] && ! [[ -h $root_dev ]] && lvcreate -l 100%FREE -Zy -n $root_label $crypt_label

! [[ $root_fs =~ ^(ext2|ext3|ext4|reiserfs|xfs|)$ ]] \
		&& Exit "Wrong value for root_fs: '$root_fs'"
if [[ $root_fs ]]
then
	Mkfs "$root_fs" "$root_label" "$root_dev" root
else
	root_fs=$(lsblk "$root_dev" -no FSTYPE 2>/dev/null)
	! [[ $root_fs ]] \
			&& Exit "Root volume is not formatted; format first or fill in 'root_fs'"
	[[ $root_fs =~ ^(ext2|ext3|ext4|reiserfs|xfs)$ ]] \
			&& Exit "Root partition has unsupported filesystem: $root_fs"
fi

! [[ $boot_fs =~ ^(ext2|ext3|ext4|reiserfs|xfs|)$ ]] \
		&& Exit "Wrong value for boot_fs: '$boot_fs'"
if [[ $boot_fs ]]
then
	Mkfs "$boot_fs" "$boot_label" "$boot_part" boot
else
	boot_fs=$(lsblk "$boot_part" -no FSTYPE 2>/dev/null)
	! [[ $boot_fs ]] \
			&& Exit "Boot partition $boot_part is not formatted; format first or fill in 'boot_fs'"
fi
boot_uuid=$(blkid -s UUID -o value "$boot_part")

## Mount
[[ $swap_size ]] && swapon "$swap_dev"
swapon -s
target='/target'
mkdir -p "$target"
mount "$root_dev" "$target"
mkdir -p "$target/boot"
mount "$boot_part" "$target/boot"
if [[ $data_size ]]
then
	mkdir -p "$target/$data_label"
	mount "$data_dev" "$target/$data_label"
fi
df --sync -hlT -x tmpfs -x devtmpfs

## Copy
cp -a "$rofs"/* "$target"

## Prepare root
cat <<-END >"$target/etc/fstab"
	proc /proc proc defaults 0 0
	$swap_dev $swap_label swap sw 0 0
	$root_dev / $root_fs relatime,errors=remount-ro 0 1
	UUID=$boot_uuid /boot $boot_fs relatime 0 2
END
[[ $data_size ]] && echo "$data_dev /$data_label $data_fs relatime 0 2" >>"$target/etc/fstab"
echo "$crypt_label UUID=$crypt_uuid none luks" >"$target/etc/crypttab"
sed "s/mint/$hostname/g" /etc/hosts >"$target/etc/hosts"
sed "s/mint/$username/g" /etc/mdm/mdm.conf >"$target/etc/mdm/mdm.conf"
echo $hostname >"$target/etc/hostname"
echo "$LANG UTF-8" >>"$target/etc/locale.gen"
rm -- "$target/etc/resolv.conf"  ## remove symlink
cp /etc/resolv.conf "$target/etc"
cp "$rself" "$target/root/$self"
mount --bind /dev "$target/dev"

## Enter the fresh installation to finish up
chroot "$target" "/root/$self" inside $username $grub_device $lmde $packages

umount "$target/dev"
umount "$target/boot"
[[ $data_size ]] && umount "$target/$data_label"
umount "$target"
[[ $swap_size ]] && swapoff "$swap_dev"
sync
sleep 1
vgchange -an
sync
sleep 1
cryptsetup luksClose $crypt_label
sync

echo -e "\n  Ready for reboot!\n"

exit 0
