#!/bin/bash
set +o xtrace +o verbose -o errexit -o errtrace

############################################################################
#
#  lmdescrypt 0.93
#
# Shortlink to download the script: http://j.mp/lmdescrypt
#
# This script installs Linux Mint Debian Edition i686 or amd64, version 201403,
#  or Linux Mint Debian Edition version 2 (201503),
#  or regular Linux Mint 17.1, 17.2, 17.3 or 18 to be:
#  Fully LUKS encrypted, with lvm2 volumes of root and swap (and optionally: data)
# The script doesn't work with UEFI-installs yet!
#
# Tutorial on Linux Mint community: https://community.linuxmint.com/tutorial/view/2265
#
# See forum topic: http://forums.linuxmint.com/viewtopic.php?f=189&t=132520
#
# Github page: https://github.com/pepa65/lmdescrypt
#
# Questions? Email solusos@passchier.net or post an Issue on the github page.
#
############################################################################
### CONTENTS:
## - INSTRUCTIONS for preparation and use
## - SETTINGS to be adjusted
## - FUNCTIONS used internally
## - INIT before anything happens
## - CHROOT to finalize the installation
## - MAIN action
############################################################################

############################################################################
#### INSTRUCTIONS
############################################################################
##
### 1. Boot the Live environment
##
### 2. Open a Terminal (Menu/Terminal of Ctrl-Alt-T) and enter:
##  wget j.mp/lmdescrypt
##
### 3. If needed, adapt the SETTINGS section:
##  nano lmdescrypt
##
### 4. Make sure all the partitions mentioned in SETTINGS exist
## For example, (re)partition the drive like this
##  (erasing all, taking up all space):
##
##  sudo fdisk /dev/sda
##  o [Enter]
##  n [Enter]
##    [Enter]
##    [Enter]
##    [Enter]
##    [Enter]
##  w [Enter]
##
## (This is giving all space to the encrypted lvm2)
##
### 5. Start the script:
##
##  chmod +x lmdescrypt
##  sudo ./lmdescrypt
##
### 6. Answer the questions as they come up:
## - password for encryption (three or four times, all the same one!)
## Then after a wait for all the preparations to have happened:
## - set password for user
## - configure keyboard
## - set timezone
##
### And that's it!
##
##
### Installing into a pre-existing environment
## Using a pre-existing boot-partition, LUKS partition and LVM Logical Volumes is entirely supported.
## Not having a separate boot partition is also supported: total encryption!
## Multiple booting with other OSes also works out of the box.
## The options are to USE (or not), to CREATE (or not), and to FORMAT (or not) these devices.
##
############################################################################

############################################################################
#### SETTINGS
############################################################################
## Review all settings below

## Adjust if needed (not needed if following the suggested partitioning)
## Specify the partitions you created by any valid device path, like:
## /dev/disk/by-label/...  /dev/...  /dev/disk/by-id/...
### Partitions to use (total encryption: boot_part should be empty)
boot_part=
crypt_part=/dev/sda1

## Adjust only if you already have a LUKS encrypted partition that you want to wipe and start from scratch
### Wipe the crypt-partition before setup, even if already set up, if 1:
force_reencrypt=0

## No strict need to adjust; only takes effect if force_reencrypt (above) is 1
## WARNING: Putting 1 here will take a LONG time (depending on the size), let it run overnight!
### Check for bad blocks and fill with pseudorandom data if 1:
force_random=0

## No need to adjust unless re-using existing volumes
## The crypt_label will also be used as the Volume Group name
## If a Volume Group or Logical Volume with this name EXISTS, IT WILL BE USED!
## The data_label will also be the name of the mountpoint
## If empty, the default NAME (in NAME_label) will be used
### Filesystem labels (no spaces):
crypt_label=crypt
boot_label=boot
root_label=root
swap_label=swap
data_label=data

## Don't allot more space than available, and at least 6GB for root
## Specify lvm2 volume sizes in gigabytes (G) or megabytes (M), no decimal points or spaces, like: 10G or 200M
## - if empty (only for swap or data) it will NOT BE USED
## - if EXISTING then the Logical Volume will not be created and needs to exist already
##   (and so should the Volume Group then!)
## - if REST (only for root or data, not both) then the rest of the available space will be used
## - DEFAULT (only for swap) means 40% of RAM size (/sys/power/image_size)
##   (See: https://www.kernel.org/doc/Documentation/power/interface.txt)
### Partition usage & sizes:
root_size=REST
swap_size=DEFAULT
data_size=

## Adjust if re-using preexisting boot or data volumes!
## Fill in the desired filesystem-type, empty means it will NOT BE FORMATTED!
##  (pre-existing filesystem will be kept!)
## Supported for boot and root: ext2 ext3 ext4 reiserfs xfs, for swap: swap
## Supported for data: ext2 ext3 ext4 hfs hfsplus jfs minix msdos ntfs reiserfs vfat xfs
### Filesystems:
boot_fs=ext4
root_fs=ext4
swap_fs=swap
data_fs=

## Adjust only if installing to a secondary drive, or needing to keep old bootloader
### Device to install grub (by any valid device path):
grub_device=/dev/sda

## Adjust if you require another encryption scheme
## Find the speeds on your hardware by: cryptsetup benchmark (and choose accordingly)
### Parameters for cryptsetup luksFormat:
cryptopts='-c aes-xts-plain -s 512 -h sha512'

## Adjust according to preference
### Username and hostname (no spaces):
username=me
hostname=mine

## Adjust according to preference
### Extra packages to be installed (in between the single quotes, seperated by space):
packages=''

############################################################################
#### FUNCTIONS
############################################################################

Exit(){	echo -e "  ERROR: $1\n  ABORTING"; exit 1;}

Mkfs(){ ## $1=fs $2=label $3=dev $4=kind
	case $1 in
		hfs|hfsplus|jfs|minix|msdos|vfat|ntfs) ! [[ $4 = data ]] && Exit "A $1 filesystem is not supported on $4" ;;&
		## Continue even if the above pattern matched
		ext2|ext3|ext4) mkfs.$1 -F -L "$2" "$3" ;;
		hfs) mkfs.$1 -h -v "$2" "$3" ;;
		hfsplus) mkfs.$1 -J -v "$2" "$3" ;;
		jfs) mkfs.$1 -q -L "$2" "$3" ;;
		minix) mkfs.$1 "$3" ;;
		msdos|vfat) mkfs.$1 -n "$2" "$3" ;;
		ntfs) mkfs.$1 -f -F -U -L "$2" "$3" ;;
		reiserfs) mkfs.$1 -ffl "$2" "$3" ;;
		xfs) mkfs.$1 -f -L "$2" "$3" ;;
		*) Exit "Unsupported filesystem $1 for $4-device $3 with label $2" ;;
	esac
}

Checklabel(){ ## $1: labelname
	label="$1_label"
	content=$(eval "echo \$$label")
	[[ $content = ${content/ } ]] || Exit "Label $label contains spaces: '$content'"
}

############################################################################
#### INIT
############################################################################

cself=$BASH_SOURCE
rself=$(readlink -e $cself)
self=$(basename $cself)
((EUID)) && Exit "This script only works when run with root privileges, like: sudo $BASH_SOURCE"
[[ -f /sys/firmware/efi ]] && Exit "This script doesn't yet work for UEFI installs!"

############################################################################
##### CHROOT
############################################################################

if [[ $1 = inside ]]
then  ## Inside the chroot of the new system on /target
	lmde=$2
	((lmde)) && [[ -d /lib/live/mount ]] && Exit "Not in chroot, can't call 'inside': $self $*"
	! ((lmde)) && [[ -d /cdrom ]] && Exit "Not in chroot, can't call 'inside': $self $*"
	shift 2
	packages=$*
	lvmetad -p /pid
	mount -t sysfs sys /sys
	mount -t proc proc /proc
	mount -t devpts pts /dev/pts
	export PS1='\[\033[01;33m\]\w \[\033[01;32m\]\$ \[\033[00m\]'
	pvscan --cache
	locale-gen --purge --no-archive
	useradd -ms /bin/bash $username
	pw="" pwa="" setting_pw=1
	while ((setting_pw))
	do
		pw=$(/lib/cryptsetup/askpass "Enter password for user $username: ")
		echo
		if [[ "$pw" ]]
		then
			pwa=$(/lib/cryptsetup/askpass "Enter the same password again: ")
			echo
				[[ "$pw" = "$pwa" ]] && setting_pw=0 || echo -e "Passwords not the same, do it again!\n"
		else
			echo "Password can't be empty!"
		fi
	done
	pwa=$(printf %${#pw}s)
	chpw="$username:$pw"
	((lmde)) && chpw="$chpw"$'\n'"root:$pw"
	pw=$pwa
	chpasswd <<<"$chpw"
	chpw=$(printf %${#chpw}s)
	addgroup $username sudo
	((lmde)) || passwd -l root
	dpkg --configure -a
	dpkg-reconfigure keyboard-configuration
	dpkg-reconfigure tzdata
	apt-get update
	rm -f /initrd.img
	[[ "$packages" ]] && apt-get --yes --reinstall install $packages
	((lmde)) && apt-get --yes purge '^live-.*'
	update-grub
	grub-install --force --recheck "$grub_device"
	gconftool-2 --set /apps/gksu/sudo-mode --type bool true
	((lmde)) && rm -rvf /lib/live
	umount /dev/pts
	umount /proc
	umount /sys
	kill -9 $(cat /pid)
	exit 0
fi

############################################################################
#### MAIN
############################################################################

## Check existence of mandatory devices
[[ -w "$crypt_part" ]] || Exit "Crypt device does not exist or is not writable: '$crypt_part'"
[[ -w "$grub_device" ]] || Exit "Grub device does not exist or is not writable: '$grub_device'"

## Check names, labels, root_fs
[[ $username =~ ^[a-z_][a-z0-9_]*$ ]] || Exit "Illegal format for username: '$username'"
[[ $hostname =~ ^[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]$ ]] || Exit "Illegal format for hostname: '$hostname'"
Checklabel crypt || exit 1
[[ -e /dev/$crypt_label ]] && Exit "Device /dev/$crypt_label exists, Volume Group name $crypt_label unavailable"
Checklabel boot || exit 1
Checklabel root || exit 1
Checklabel swap || exit 1
Checklabel data || exit 1
! [[ $root_fs =~ ^(ext2|ext3|ext4|reiserfs|xfs|)$ ]] \
		&& Exit "Wrong value for root_fs: '$root_fs'"

## Determine root and data partition usage & size
[[ $root_size ]] && ! [[ $root_size = REST ]] && ! [[ $root_size = EXISTING ]] \
		&& ! [[ $root_size =~ [1-9][0-9]*[MG] ]] \
		&& Exit "Invalid format root_size: '$root_size'"
if [[ $data_size = REST ]]
then
	[[ $root_size = REST ]] && Exit "Settings data_size and root_size can't both be REST"
	lvm_data='-l 100%FREE -Zy'
else
	if [[ $data_size ]]
	then
		! [[ $data_size =~ [1-9][0-9]*[MG] ]] \
				&& Exit "Invalid format data_size: '$data_size'"
		lvm_data="-L $data_size -Zy"
	fi
fi

## Set swap size
if [[ $swap_size = DEFAULT ]]
then
	lvm_swap="-L $(cat /sys/power/image_size)B -Cy -Zy"
else
	if ! [[ $swap_size = EXISTING ]]
	then
		[[ $swap_size ]] && ! [[ $swap_size =~ [1-9][0-9]*[MG] ]] \
				&& Exit "Invalid format swap_size: $swap_size"
		lvm_swap="-L $swap_size -Cy -Zy"
	fi
fi

packages+=" linux-image-$(uname -r)"

rofsde='/lib/live/mount/rootfs/filesystem.squashfs'
rofslm='/rofs'
if [[ -d /lib/live ]]
then  ## Debian Edition
	lmde=1
	rofs=$rofsde
else  ## regular Mint
	lmde=0
	rofs=$rofslm
fi

## Encrypt
if ((force_reencrypt))
then
	((force_random)) && badblocks -c 10240 -s -w -t random -v "$crypt_part"
	cryptsetup luksFormat $cryptopts "$crypt_part"
else
	cryptsetup isLuks "$crypt_part" && echo -e "\n  $crypt_part is already formatted, reencryption not forced" \
			|| cryptsetup luksFormat $cryptopts "$crypt_part"
fi
if ! [[ $boot_part ]]
then
	key=crypto_keyfile.bin
	dd bs=512 count=4 if=/dev/urandom of="$key"
	cryptsetup luksAddKey "$crypt_part" "$key"
fi

## Decrypt if not yet mapped
crypt_dev="/dev/mapper/$crypt_label"
[[ -b "$crypt_dev" ]] || cryptsetup luksOpen "$crypt_part" $crypt_label
crypt_uuid=$(blkid -s UUID -o value "$crypt_part")

## Make lvm2 volumes if not there yet and format if wanted
[[ "  $crypt_label" = "$(vgs --noheadings -o vg_name)" ]] || vgcreate -Zy $crypt_label $crypt_dev
vgchange --refresh
root_dev="/dev/$crypt_label/$root_label"
data_dev="/dev/$crypt_label/$data_label"
swap_dev="/dev/$crypt_label/$swap_label"

## Create & format swap if wanted
if [[ $swap_size ]]
then
	! [[ -h $swap_dev ]] && lvcreate $lvm_swap -n $swap_label $crypt_label
	[[ $swap_fs = swap ]] && mkswap -f -L $swap_label "$swap_dev" \
			|| Exit "Wrong value for swap_fs: '$swap_fs'" 
fi

## Create and format root partition, and data partition if wanted
! [[ $root_size = REST ]] && ! [[ -h $root_dev ]] && lvcreate -L $root_size -Zy -n $root_label $crypt_label
if [[ $data_size ]]
then  ## Create if it doesn't exist and format if required
	if [[ -h $root_dev ]]
	then
		data_fs=$(lsblk "$data_dev" -no FSTYPE 2>/dev/null)
		! [[ $data_fs ]] \
				&& Exit "Data volume is not formatted; format first or fill in 'data_fs'"
	else
		! [[ $data_fs ]] && Exit "Can't create data partition without format"
		lvcreate $lvm_data -n $data_label $crypt_label
		Mkfs "$data_fs" "$data_label" "$data_dev" data
	fi
fi
[[ $root_size = REST ]] && ! [[ -h $root_dev ]] && lvcreate -l 100%FREE -Zy -n $root_label $crypt_label
if [[ $root_fs ]]
then
	Mkfs "$root_fs" "$root_label" "$root_dev" root
else
	root_fs=$(lsblk "$root_dev" -no FSTYPE 2>/dev/null)
	! [[ $root_fs ]] \
			&& Exit "Root volume is not formatted; format first or fill in 'root_fs'"
	[[ $root_fs =~ ^(ext2|ext3|ext4|reiserfs|xfs)$ ]] \
			&& Exit "Root partition has unsupported filesystem: $root_fs"
fi

if [[ $boot_part ]]
then
	! [[ $boot_fs =~ ^(ext2|ext3|ext4|reiserfs|xfs|)$ ]] \
			&& Exit "Wrong value for boot_fs: '$boot_fs'"
	if [[ $boot_fs ]]
	then
		Mkfs "$boot_fs" "$boot_label" "$boot_part" boot
	else
		boot_fs=$(lsblk "$boot_part" -no FSTYPE 2>/dev/null)
		! [[ $boot_fs ]] \
				&& Exit "Boot partition $boot_part is not formatted; format first or fill in 'boot_fs' or leave boot_part empty"
	fi
	boot_uuid=$(blkid -s UUID -o value "$boot_part")
fi

## Mount
[[ $swap_size ]] && swapon "$swap_dev" && swapon -s
target='/target'
mkdir -p "$target"
mount "$root_dev" "$target"
if [[ $boot_part ]]
then
	mkdir -p "$target/boot"
	mount "$boot_part" "$target/boot"
fi
if [[ $data_size ]]
then
	mkdir -p "$target/$data_label"
	mount "$data_dev" "$target/$data_label"
fi
df --sync -hlT -x tmpfs -x devtmpfs

## Copy
cp -a "$rofs"/* "$target"

## Prepare root
echo "proc /proc proc defaults 0 0" >"$target/etc/fstab"
echo "$root_dev / $root_fs relatime,errors=remount-ro 0 1" >>"$target/etc/fstab"
[[ $swap_size ]] && echo "$swap_dev $swap_label swap sw 0 0" >>"$target/etc/fstab"
[[ $data_size ]] && echo "$data_dev /$data_label $data_fs relatime 0 2" >>"$target/etc/fstab"
if [[ $boot_part ]]
then
	echo "UUID=$boot_uuid /boot $boot_fs relatime 0 2" >>"$target/etc/fstab"
	p3=none
	p4=luks
else
	keytarget="$target/etc/initramfs-tools/hooks/crypto_keyfile"
	mv "$key" "$target/$key"
	chmod 000 "$target/$key"
	echo "cp /$key \"\${DESTDIR}\"" >"$keytarget"
	chmod +x "$keytarget"
	sed -i '/^GRUB_TIMEOUT/a GRUB_ENABLE_CRYPTODISK=y' "$target/etc/default/grub"
	gcl="GRUB_CMDLINE_LINUX=\"cryptdevice=$crypt_part:$crypt_label\""
	sed -i "s@^GRUB_CMDLINE_LINUX=\"\"@$gcl@" "$target/etc/default/grub"
	p3="/$key"
	p4="luks,keyscript=/bin/cat"
fi
sed -i 's/^GRUB_TIMEOUT=10/GRUB_TIMEOUT=4/' "$target/etc/default/grub"
sed -i 's/^GRUB_HIDDEN_TIMEOUT=0/#GRUB_HIDDEN_TIMEOUT=0/' "$target/etc/default/grub"
echo "$crypt_label UUID=$crypt_uuid $p3 $p4" >"$target/etc/crypttab"
sed "s/mint/$hostname/g" /etc/hosts >"$target/etc/hosts"
sed "s/mint/$username/g" /etc/mdm/mdm.conf >"$target/etc/mdm/mdm.conf"
echo $hostname >"$target/etc/hostname"
echo "$LANG UTF-8" >>"$target/etc/locale.gen"
rm -- "$target/etc/resolv.conf"  ## remove symlink
cp /etc/resolv.conf "$target/etc"
cp "$rself" "$target/root/$self"
mount --bind /dev "$target/dev"

## Enter the fresh installation to finish up
chroot "$target" "/root/$self" inside $lmde $packages

umount "$target/dev"
[[ $boot_part ]] && umount "$target/boot"
[[ $data_size ]] && umount "$target/$data_label"
umount "$target"
[[ $swap_size ]] && swapoff "$swap_dev"
sync
sleep 1
vgchange -an
sync
sleep 1
cryptsetup luksClose $crypt_label
sync

echo -e "\n  Ready for reboot!\n"

exit 0
