#!/bin/bash
set +o xtrace -o verbose -o errexit -o errtrace
############################################################################
#
#  lmdescrypt 0.77
#
# This script installs Linux Mint Debian Edition i686 or amd64, version 201403,
#  or Linux Mint Debian Edition version 2 (201504)
#  or regular Linux Mint 17.1 or 17.2 or 17.3 to be:
#  Fully luks encrypted, with lvm2 volumes of root, swap and (optionally) data
#
# Github page: https://github.com/pepa65/lmdescrypt
#
# See forum topic: http://forums.linuxmint.com/viewtopic.php?f=189&t=132520
# Shortlink to download the script: http://j.mp/lmdescrypt
# Questions?  solusos@passchier.net or post an Issue on the github page
#
############################################################################
### CONTENTS:
## - INSTRUCTIONS for preparation and use
## - SETTINGS to be adjusted
## - FUNCTIONS
## - INIT
## - MAIN
############################################################################

############################################################################
#### INSTRUCTIONS
############################################################################
##
### 1. Boot the Live environment
##
### 2. Open a Terminal (Menu, Terminal) and enter:
##  wget j.mp/lmdescrypt
##  chmod +x lmdescrypt
##
### 3. If needed, adapt the SETTINGS section:
##  nano lmdescrypt
##
### 4. Partition the drive, for instance (taking up all space):
##
##  sudo fdisk /dev/sda
##  o [Enter]
##  n [Enter]
##    [Enter]
##    [Enter]
##    [Enter]
##  +500M [Enter]
##  n [Enter]
##    [Enter]
##    [Enter]
##    [Enter]
##    [Enter]
##  w [Enter]
##
## (This is making a 500 MB boot partition, and giving the rest to the encrypted lvm2)
##
### 5. Start the script:
##
##  sudo ./lmdescrypt
##
### 6. Answer the questions as they come up:
## - password for encryption (twice the same)
## - password for decryption (same again)
## Then after a wait for all the preparations to have happened:
## - password for user, and some irrelevant info
## - about the keyboard
## - about the timezone
##
### Installing into a pre-existing environment
## Using a pre-existing boot-partition, LUKS partition and LVM Logical Volumes is entirely supported.
## There is the option to USE (or not), to CREATE (or not), and to FORMAT (or not) these devices.
##
### And that's it!
#
############################################################################

############################################################################
#### SETTINGS
############################################################################
## Review all settings below

### Adjust only if not following the partitioning suggestions, or installing to a secondary drive
## Specify the partitions you created by any valid device path, like:
## /dev/disk/by-label/...  /dev/...  /dev/disk/by-id/...
boot_part=/dev/sda1
crypt_part=/dev/sda2

### Adjust only if you already have a LUKS encrypted partition that you want to wipe and start from scratch
## This setting will be automatically be 1 if force_random is set to 1 (next item)!
## Indicate that you want the crypt-partition wiped even if already setup by putting 1:
force_reencrypt=0

### No strict need to adjust
## WARNING: Putting 1 here will take a LONG time (depending on the size), let it run overnight!
## Indicate that you want to check for bad blocks and fill with pseudorandom data by putting 1 (otherwise 0):
force_random=0

### No need to adjust; according to preference
## If a Volume Group or Logical Volume with the same name exists, it will be used!
## If swap_label and/or data_label are -empty-, they will NOT BE USED! (Whether it pre-exists or not)
## The crypt_label will also be used as the Volume Group name
## The data_label will also be the name of the mountpoint
## Specify the filesystem labels (no spaces):
crypt_label=crypt
boot_label=boot
root_label=root
swap_label=swap
data_label=data

### Make sure you're not allotting more space than what's available, and enough for root (6GB at least)!
## Specify lvm2 volume sizes in gigabytes (G) or megabytes (M), no decimal points or spaces, like: 10G or 200M
## - if -empty- then the volume will NOT BE CREATED! (whether it pre-exists or not)
## - if REST (only for root or data, not both) then the rest of the available space will be used
## - if DEFAULT for swap that means: MEMSIZE+100M
root_size=20G
swap_size=DEFAULT
data_size=REST

### Adjust if re-using preexisting boot or data volumes!
## Fill in the desired filesystem-type, -empty- means it will NOT BE FORMATTED! (install over current content)
## Supported for boot and root: ext2 ext3 ext4 reiserfs xfs.
## Supported for data: ext2 ext3 ext4 hfs hfsplus jfs minix msdos ntfs reiserfs vfat xfs
boot_format=ext2
root_format=ext4
data_format=ext4

### Adjust only if installing to a secondary drive, or needing to keep old bootloader
## Specify the device where to install grub by any valid device path:
grub_device=/dev/sda

### Adjust if you require another encryption scheme
## Find the speeds on your hardware by: cryptsetup benchmark (and choose accordingly)
## These are the parameters that are fed to cryptsetup luksFormat:
cryptopts='-c aes-xts-plain -s 512 -h sha512'

### Adjust according to preference
## Specify your preferred username and hostname (no spaces):
username=me
hostname=mine

### Adjust according to preference
## Specify extra packages to be installed (in between the single quotes, seperated by space):
packages=''

############################################################################
#### FUNCTIONS
############################################################################

Exit(){	echo -e "  ERROR: $1\n  ABORTING"; exit 1;}

Mkfs(){ ## $1=fs $2=label $3=dev $4=kind
	case $1 in
		hfs|hfsplus|jfs|minix|msdos|vfat|ntfs) ! [[ $4 = data ]] && Exit "A $1 filesystem is not supported on $4" ;;&
		## Continue even if the above pattern matched
		ext2|ext3|ext4) mkfs.$1 -F -L "$2" "$3" ;;
		hfs) mkfs.$1 -h -v "$2" "$3" ;;
		hfsplus) mkfs.$1 -J -v "$2" "$3" ;;
		jfs) mkfs.$1 -q -L "$2" "$3" ;;
		minix) mkfs.$1 "$3" ;;
		msdos|vfat) mkfs.$1 -n "$2" "$3" ;;
		ntfs) mkfs.$1 -f -F -U -L "$2" "$3" ;;
		reiserfs) mkfs.$1 -ffl "$2" "$3" ;;
		xfs) mkfs.$1 -f -L "$2" "$3" ;;
		*) Exit "Unsupported filesystem $1 for $4-device $3 with label $2" ;;
	esac
}

############################################################################
#### INIT
############################################################################

cself=$BASH_SOURCE
rself=$(readlink -e $cself)
self=$(basename $cself)
((EUID)) && Exit "This script only works when run with root privileges, like: sudo $BASH_SOURCE"

target='/target'
crypt_map="/dev/mapper/$crypt_label"
root_map="/dev/mapper/$crypt_label-$root_label"
data_map="/dev/mapper/$crypt_label-$data_label"
swap_map="/dev/mapper/$crypt_label-$swap_label"

[[ -w "$boot_part" ]] || Exit "Boot device does not exist or is not writable: $boot_part"
[[ -w "$crypt_part" ]] || Exit "Crypt device does not exist or is not writable: $crypt_part"
[[ -w "$grub_device" ]] || Exit "Grub device does not exist or is not writable: $grub_device"
[[ $username =~ ^[a-z_][a-z0-9_]*$ ]] || Exit "Illegal format for username: $username"
[[ $hostname =~ ^[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]$ ]] || Exit "Illegal format for hostname: $hostname"
[[ $crypt_label ]] || Exit "Label crypt_label must be filled in!"
[[ $crypt_label = "${crypt_label/ /}" ]] || Exit "Label 'crypt_label' contains spaces: $crypt_label"
[[ $boot_label ]] || Exit "Label boot_label must be filled in!"
[[ $boot_label = "${boot_label/ /}" ]] || Exit "Label 'boot_label' contains spaces: $boot_label"
[[ $root_label ]] || Exit "Label root_label must be filled in!"
[[ $root_label = "${root_label/ /}" ]] || Exit "Label 'root_label' contains spaces: $root_label"
[[ $swap_label = "${swap_label/ /}" ]] || Exit "Label 'swap_label' contains spaces: $swap_label"
[[ $swap_label ]] && ! [[ $swap_size ]] && ! [[ -b $swap_map ]] \
		&& Exit "There is no pre-existing swap volume $swap_label, and no 'swap_size' given to make one"
[[ $data_label = "${data_label/ /}" ]] || Exit "Label 'data_label' contains spaces: $data_label"
if [[ $data_label ]]
then
	! [[ -b $data_map ]] && ! [[ $data_size ]] \
			&& Exit "There is no pre-existing data volume $data_label, and no 'data_size' given to make one"
	! [[ -b $data_map ]] && ! [[ $data_format ]] \
			&& Exit "Can't use a newly created data volume without formatting, fill in 'data_format'"
fi

## Pre-existing volumes that are not going to be formatted, need to determine their filesystem
! [[ $boot_format ]] && boot_fs=$(lsblk "$boot_part" -no FSTYPE) || boot_fs=$boot_format
! [[ $boot_fs ]] && Exit "Boot partition $boot_part is not formatted; format first or fill in 'boot_format'"
! [[ $root_format ]] && root_fs=$(lsblk "$root_map" -no FSTYPE) || root_fs=$root_format
! [[ $root_fs ]] && Exit "Root volume is not formatted; format first or fill in 'root_format'"
! [[ $data_format ]] && data_fs=$(lsblk "$data_map" -no FSTYPE) || data_fs=$data_format
! [[ $data_fs ]] && Exit "Data volume is not formatted; format first or fill in 'data_format'"

rofsde='/lib/live/mount/rootfs/filesystem.squashfs'
rofslm='/rofs'
if [[ -d /lib/live ]]
then  ## Debian Edition
	lmde=1
	rofs=$rofsde
	## Detect whether on Live system or not
	[[ -d /lib/live/mount ]] && inchroot=0 || inchroot=1
else  ## regular Mint
	lmde=0
	rofs=$rofslm
	## Detect whether on Live system or not
	[[ -d /cdrom ]] && inchroot=0 || inchroot=1
fi

case $1 in
	inside)  ## Inside the chroot of the new system on /target
		! ((inchroot)) && Exit "Invalid call 'inside' when not in chroot: $self $*"
		username=$2
		grub_device=$3
		shift 3
		packages=$*
		mount -t sysfs sys /sys
		mount -t proc proc /proc
		mount -t devpts pts /dev/pts
		export PS1='\[\033[01;33m\]\w \[\033[01;32m\]\$ \[\033[00m\]'
		locale-gen
		useradd -ms /bin/bash $username
		until passwd $username; do :;done
		addgroup $username sudo
		passwd -l root
		dpkg --configure -a
		dpkg-reconfigure keyboard-configuration
		dpkg-reconfigure tzdata
		apt-get update
		rm -f /initrd.img
		[[ "$packages" ]] && apt-get --yes --force-yes --reinstall install $packages
		((lmde)) && apt-get --yes purge '^live-.*'
		update-grub
		grub-install --recheck --force "$grub_device"
		((lmde)) && rm -rvf /lib/live
		umount /dev/pts
		umount /proc
		umount /sys
		exit 0 ;;
	'')
		((inchroot)) && Exit "Invalid plain command $self, not in live environment" ;;
	*)
		Exit "Unknown first argument to $self: $*" ;;
esac

[[ $root_size ]] && ! [[ $root_size = REST ]] && ! [[ $root_size =~ [1-9][0-9]*[MG] ]] \
		&& Exit "Invalid format root_size: $root_size"
if [[ $data_size = REST ]]
then
	[[ $root_size = REST ]] && Exit "Settings data_size and root_size can't both be REST"
	lvmdata='-l 100%FREE -Zn'
else
	if [[ $data_size ]]
	then
		! [[ $data_size =~ [1-9][0-9]*[MG] ]] && Exit "Invalid format data_size: $data_size"
		lvmdata="-L $data_size -Zn"
	fi
fi

if [[ $swap_size = DEFAULT ]]
then
	lvmswap="-L $(($(head -1 /proc/meminfo |sed 's/[^0-9]//g')+100000))K -Cy -Zn"
else
	if [[ $swap_size ]]
	then
		! [[ $swap_size =~ [1-9][0-9]*[MG] ]] && Exit "Invalid format swap_size: $swap_size"
		lvmswap="-L $swap_size -Cy -Zn"
	fi
fi

((force_random)) && force_reencrypt=1
packages+=" linux-image-$(uname -r)"

############################################################################
#### MAIN
############################################################################

## Encrypt
if ((force_reencrypt))
then
	((force_random)) && badblocks -c 10240 -s -w -t random -v "$crypt_part"
	cryptsetup luksFormat $cryptopts "$crypt_part"
else
	cryptsetup isLuks "$crypt_part" && echo -e "\n  $crypt_part is already formatted, reencryption not forced" \
			|| cryptsetup luksFormat $cryptopts "$crypt_part"
fi

## Decrypt if not yet mapped
[[ -b "$crypt_map" ]] || cryptsetup luksOpen "$crypt_part" $crypt_label
crypt_uuid=$(blkid -s UUID -o value "$crypt_part")
dmsetup status

## Make lvm2 volumes if not there yet and format if wanted
grep " $crypt_label$" <<<"$(vgs --noheadings -o vg_name)" || vgcreate $crypt_label $crypt_map

[[ $swap_size ]] && ! [[ -b "$swap_map" ]] && sleep 1 && lvcreate $lvmswap -n $swap_label $crypt_label
[[ $swap_label ]] && mkswap -f -L $swap_label "$swap_map"

! [[ $root_size = REST ]] && ! [[ -b "$root_map" ]] && sleep 1 && lvcreate -L $root_size -Zn -n $root_label $crypt_label
if [[ $data_size ]]
then
	! [[ -b "$data_map" ]] && sleep 1 && lvcreate $lvmdata -n $data_label $crypt_label
	[[ $data_format ]] && Mkfs "$data_format" "$data_label" "$data_map" data
fi
[[ $root_size = REST ]] && ! [[ -b "$root_map" ]] && sleep 1 && lvcreate -l 100%FREE -Zn -n $root_label $crypt_label
[[ $root_format ]] && Mkfs "$root_format" "$root_label" "$root_map" root

[[ $boot_format ]] && Mkfs "$boot_format" "$boot_label" "$boot_part" boot
boot_uuid=$(blkid -s UUID -o value "$boot_part")

## Mount
[[ $swap_label ]] && swapon "$swap_map"
swapon -s
mkdir -p "$target"
mount "$root_map" "$target"
mkdir -p "$target/boot"
mount "$boot_part" "$target/boot"
if [[ $data_label ]]
then
	mkdir -p "$target/$data_label"
	mount "$data_map" "$target/$data_label"
fi
df --sync -hlT -x tmpfs -x devtmpfs

## Copy
cp -a "$rofs"/* "$target"

## Prepare root
cat <<-END >"$target/etc/fstab"
	proc /proc proc defaults 0 0
	$swap_map $swap_label swap sw 0 0
	$root_map / $root_fs relatime,errors=remount-ro 0 1
	UUID=$boot_uuid /boot $boot_fs relatime 0 2
END
[[ $data_label ]] && echo "$data_map /$data_label $data_fs relatime 0 2" >>"$target/etc/fstab"
echo "$crypt_label UUID=$crypt_uuid none luks" >"$target/etc/crypttab"
sed "s/mint/$hostname/g" /etc/hosts >"$target/etc/hosts"
sed "s/mint/$username/g" /etc/mdm/mdm.conf >"$target/etc/mdm/mdm.conf"
echo $hostname >"$target/etc/hostname"
echo "$LANG UTF-8" >>"$target/etc/locale.gen"
rm -- "$target/etc/resolv.conf"  ## remove symlink
cp /etc/resolv.conf "$target/etc"
cp "$rself" "$target/root/$self"
mount --bind /dev "$target/dev"
chroot "$target" "/root/$self" inside $username $grub_device $packages

umount "$target/dev"
umount "$target/boot"
[[ $data_size ]] && umount "$target/$data_label"
umount "$target"
[[ $swap_size ]] && swapoff "$swap_map"
sync
sleep 1
vgchange -an
sync
sleep 1
cryptsetup luksClose $crypt_label
sync

echo -e "\n  Ready for reboot!\n"

exit 0
