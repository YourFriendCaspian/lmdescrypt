#!/bin/bash
set +o xtrace -o verbose -o errexit -o errtrace
############################################################################
#
#  lmdescrypt 0.72
#
# This script installs Linux Mint Debian Edition i686 or amd64, version 201403,
#  or Linux Mint Debian Edition version 2 (201504)
#  or regular Linux Mint 17.1 or 17.2 or 17.3 to be:
#  Fully luks encrypted, with lvm2 volumes of root, swap and (optionally) data
#
# Github page: https://github.com/pepa65/lmdescrypt
#
# See forum topic: http://forums.linuxmint.com/viewtopic.php?f=189&t=132520
# Shortlink to download the script: http://j.mp/lmdescrypt
# Questions?  solusos@passchier.net or post an Issue on the github page
#
############################################################################
### CONTENTS:
## - INSTRUCTIONS for preparation and use
## - SETTINGS to be adjusted
## - FUNCTIONS
## - INIT
## - MAIN
############################################################################

############################################################################
#### INSTRUCTIONS
############################################################################
##
### 1. Boot the Live environment
##
### 2. Open a Terminal (Menu, Terminal) and enter:
##  wget j.mp/lmdescrypt
##  chmod +x lmdescrypt
##
### 3. If needed, adapt the SETTINGS section:
##  nano lmdescrypt
##
### 4. Partition the drive, for instance (taking up all space):
##
##  sudo fdisk /dev/sda
##  o [Enter]
##  n [Enter]
##    [Enter]
##    [Enter]
##    [Enter]
##  +500M [Enter]
##  n [Enter]
##    [Enter]
##    [Enter]
##    [Enter]
##    [Enter]
##  w [Enter]
##
## (This is making a 500 MB boot partition, and giving the rest to the encrypted lvm2)
##
### 5. Start the script:
##
##  sudo ./lmdescrypt
##
### 6. Answer the questions as they come up:
## - password for encryption (twice the same)
## - password for decryption (same again)
## Then after a wait for all the preparations to have happened:
## - password for user, and some irrelevant info
## - about the keyboard
## - about the timezone
##
### Installing into a pre-existing environment
## If there is already a boot-partition and/or a LVM partition that you want to use,
## that is entirely supported. Make sure that in editing the script, you make sure you have nothing
## listed as filesystem-type (then it doesn't get formatted). The root partition always gets formatted!!
## In LVM, if you're using pre-existing names for the Volume Group and/or the Logical Volumes (partitions),
## They won't get created.
##
### And that's it!
#
############################################################################

############################################################################
#### SETTINGS
############################################################################
## Review all settings below

### Adjust only if not following the partitioning suggestions, or installing to a secondary drive
## Specify the partitions you created by any valid device path, like:
## /dev/disk/by-label/...  /dev/...  /dev/disk/by-id/...
boot_device=/dev/sda1
crypt_device=/dev/sda2

### Adjust only if you already have a LUKS encrypted partition that you want to wipe and start from scratch
## This setting will be automatically be 1 if force_random is set to 1 (next item)!
## Indicate that you want the crypt-partition wiped even if already setup by putting 1:
force_reencrypt=0

### No strict need to adjust
## WARNING: Putting 1 here will take a LONG time (depending on the size), let it run overnight!
## Indicate that you want to check for bad blocks and fill with pseudorandom data by putting 1 (otherwise 0):
force_random=0

### Make sure you're not allotting more space than what's available, and enough for root (6GB at least)!
## Specify lvm2 volume sizes in gigabytes (G) or megabytes (M), no decimal points, like: 10G or 200M
## - if empty then no attempt will be made to create that volume
## - if REST (only for root or data, not both) then the rest of the available space will be used
## - if DEFAULT then root=20G swap=MEMSIZE+100M data=REST
## - if REST or DEFAULT are misspelled (case sensitive!), it's taken to be 0!
root_size=REST
swap_size=DEFAULT
data_size=

### Adjust If re-using preexisting boot or data volumes
##  root will always be formatted! (if not specified, ext4 will be used)
format_root=ext4
## Fill in the desired filesystem-type, empty means no formatting (install over the current content):
format_boot=ext2
format_swap=swap
format_data=ext4

### No need to adjust; according to preference
## The crypt_label will also be used as the Volumegroup-name
## The data_label will also be the name of the mountpoint
## If a Volumegroup or Logical volume with the same name exists, it will be used
## Specify the filesystem labels (no spaces):
crypt_label=crypt
boot_label=boot
root_label=root
swap_label=swap
data_label=data

### Adjust only if installing to a secondary drive, or needing to keep old bootloader
## Specify the device where to install grub by any valid device path:
grub_device=/dev/sda

### Adjust if you require another encryption scheme
## Find the speeds on your hardware by: cryptsetup benchmark (and choose accordingly)
## These are the parameters that are fed to cryptsetup luksFormat:
cryptopts='-c aes-xts-plain -s 512 -h sha512'

### Adjust according to preference
## Specify your preferred username and hostname (no spaces):
username=me
hostname=mine

### Adjust according to preference
## Specify extra packages to be installed (in between the single quotes, seperated by space):
packages=''

############################################################################
#### FUNCTIONS
############################################################################

Exit(){	echo -e "  ERROR: $1\n  ABORTING"; exit 1;}

Rechroot(){
	cryptsetup luksOpen "$crypt_device" $crypt_label
	sync
	vgchange -ay
	sync
	swapon "$swap_device"
	mkdir -p "$target"
	mount "$root_device" "$target"
	mkdir -p "$target/boot"
	mount "$boot_device" "$target/boot"
	((data_size)) && mkdir -p "$target/$data_label" && mount "$data_device" "$target/$data_label"
	df --sync -hlT -x tmpfs -x devtmpfs
	mount --bind /dev "$target/dev"
	chroot "$target"
	Mountinside
}

Mountinside(){
	mount -t sysfs sys /sys
	mount -t proc proc /proc
	mount -t devpts pts /dev/pts
	export PS1='\[\033[01;33m\]\w \[\033[01;32m\]\$ \[\033[00m\]'
}

Unmountinside(){
	umount /dev/pts
	umount /proc
	umount /sys
}

Unmountall(){
	umount "$target/dev"
	umount "$target/boot"
	[[ $data_size ]] && umount "$target/$data_label"
	umount "$target"
	[[ $swap_size ]] && swapoff "$swap_device"
	sync
	sleep 1
	vgchange -an
	sync
	sleep 1
	cryptsetup luksClose $crypt_label
	sync
}

Inside(){ # 1:$username 2:$grub_device $packages
	username=$1
	grub_device=$2
	shift 2
	packages=$*
	Mountinside
	locale-gen
	useradd -ms /bin/bash $username
	until passwd $username; do :;done
	addgroup $username sudo
	passwd -l root
	dpkg --configure -a
	dpkg-reconfigure keyboard-configuration
	dpkg-reconfigure tzdata
	apt-get update
	rm -f /initrd.img
	[[ "$packages" ]] && apt-get --yes --force-yes --reinstall install $packages
	((lmde)) && apt-get --yes purge '^live-.*'
	update-grub
	grub-install --recheck --force "$grub_device"
	((lmde)) && rm -rvf /lib/live
	Unmountinside
}

############################################################################
#### INIT
############################################################################

[[ -w "$boot_device" ]] || Exit "Boot device does not exist or is not writable: $boot_device"
[[ -w "$crypt_device" ]] || Exit "Crypt device does not exist or is not writable: $crypt_device"
[[ -w "$grub_device" ]] || Exit "Grub device does not exist or is not writable: $grub_device"
[[ $username =~ ^[a-z_][a-z0-9_]*$ ]] || Exit "Illegal format for username: $username"
[[ $hostname =~ ^[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]$ ]] || Exit "Illegal format for hostname: $hostname"
[[ $crypt_label = "${crypt_label/ /}" ]] || Exit "Label crypt_label contains spaces: $crypt_label"
[[ $boot_label = "${boot_label/ /}" ]] || Exit "Label boot_label contains spaces: $boot_label"
[[ $root_label = "${root_label/ /}" ]] || Exit "Label root_label contains spaces: $root_label"
[[ $swap_label = "${swap_label/ /}" ]] || Exit "Label swap_label contains spaces: $swap_label"
[[ $data_label = "${data_label/ /}" ]] || Exit "Label data_label contains spaces: $data_label"

target='/target'
root_device="/dev/mapper/$crypt_label-$root_label"
data_device="/dev/mapper/$crypt_label-$data_label"
swap_device="/dev/mapper/$crypt_label-$swap_label"

rofsde='/lib/live/mount/rootfs/filesystem.squashfs'
rofslm='/rofs'
if [[ -d /lib/live ]]
then  ## Debian Edition
	lmde=1
	rofs=$rofsde
	## Detect whether on Live system or not
	[[ -d /lib/live/mount ]] && inside=0 || inside=1
else  ## regular Mint
	lmde=0
	rofs=$rofslm
	## Detect whether on Live system or not
	[[ -d /cdrom ]] && inside=0 || inside=1
fi

self=$(basename $0)
case $1 in
	inside)
		((inside)) || Exit "Invalid call 'inside', not in chroot: $self $*"
		shift
		Inside $*
		exit 0 ;;
	rechroot)
		((inside)) && Exit "Invalid call 'rechroot', not in live environment: $self $*"
		Rechroot
		exit 0 ;;
	mountinside)
		((inside)) || Exit "Invalid call 'mountinside', not in chroot: $self $*"
		Mountinside
		exit 0 ;;
	unmountinside)
		((inside)) || Exit "Invalid call 'unmountinside', not in chroot: $self $*"
		Unmountinside
		exit 0 ;;
	unmountrest)
		((inside)) && Exit "Invalid call 'unmountrest', not in live environment: $self $*"
		Unmountall
		exit 0 ;;
	'')
		((inside)) && Exit "Invalid command $self, not in live environment" ;;
	*)
		Exit "Unknown first argument to $self: $*" ;;
esac

[[ $root_size = DEFAULT ]] && root_size=20G
! [[ $root_size = REST ]] && ! [[ $root_size =~ [1-9][0-9]*[MG] ]] && Exit "Unacceptable format root_size: $root_size"

[[ $data_size = DEFAULT ]] && data_size=REST
if [[ $data_size = REST ]]
then
	[[ $root_size = REST ]] && Exit "Settings data_size and root_size can't both be REST"
	lvmdata='-l 100%FREE -Zn'
else
	! [[ $data_size =~ [1-9][0-9]*[MG] ]] && Exit "Unacceptable format data_size: $data_size"
	lvmdata="-L $data_size -Zn"
fi

if [[ $swap_size = DEFAULT ]]
then
	lvmswap="-L $(($(head -1 /proc/meminfo |sed 's/[^0-9]//g')+100000))K -Cy -Zn"
else
	! [[ $swap_size =~ [1-9][0-9]*[MG] ]] && Exit "Unacceptable format swap_size: $swap_size"
	lvmswap="-L $swap_size -Cy -Zn"
fi

((force_random)) && force_reencrypt=1
packages+=" linux-image-$(uname -r)"

############################################################################
#### MAIN
############################################################################

## Encrypt
if ((force_reencrypt))
then
	((force_random)) && badblocks -c 10240 -s -w -t random -v "$crypt_device"
	cryptsetup luksFormat $cryptopts "$crypt_device"
else
	cryptsetup isLuks "$crypt_device" && echo -e "\n  $crypt_device is already formatted, reencryption not forced" \
			|| cryptsetup luksFormat $cryptopts "$crypt_device"
fi

## Decrypt if not yet mapped
[[ -b "/dev/mapper/$crypt_label" ]] || cryptsetup luksOpen "$crypt_device" $crypt_label
crypt_uuid=$(blkid -s UUID -o value "$crypt_device")
dmsetup status

## Make lvm2 volumes if not there yet and format if wanted
grep " $crypt_label$" <<<"$(vgs --noheadings -o vg_name)" || vgcreate $crypt_label /dev/mapper/$crypt_label
if [[ $swap_size ]]
then
	[[ -b "$swap_device" ]] || lvcreate $lvmswap -n $swap_label $crypt_label
	[[ $format_swap ]] && mkswap -f -L $swap_label "$swap_device"
	swap_uuid=$(blkid -s UUID -o value "$swap_device")
fi

! [[ $root_size = REST ]] && ! [[ -b "$root_device" ]] && lvcreate -L $root_size -Zn -n $root_label $crypt_label
if [[ $data_size ]]
then
	[[ -b "$data_device" ]] || lvcreate $lvmdata -n $data_label $crypt_label
	[[ $format_data ]] && mkfs -F -t "$format_data" -j -m 0 -L $data_label "$data_device"
	data_uuid=$(blkid -s UUID -o value "$data_device")
fi
[[ $root_size = REST ]] && ! [[ -b "$root_device" ]] && lvcreate -l 100%FREE -Zn -n $root_label $crypt_label
[[ $format_root ]] || format_root=ext4
mkfs -F -t "$format_root" -j -L $root_label "$root_device"
root_uuid=$(blkid -s UUID -o value "$root_device")
[[ $format_boot ]] && mkfs -F -t "$format_boot" -L $boot_label "$boot_device"
boot_uuid=$(blkid -s UUID -o value "$boot_device")

## Mount
swapon "$swap_device"
swapon -s
mkdir -p "$target"
mount "$root_device" "$target"
mkdir -p "$target/boot"
mount "$boot_device" "$target/boot"
! [[ $format_boot ]] && h=$(fsck -N "$target/boot"|grep -o ' fsck.[^ ]*') && format_boot=${h##*.}
if [[ $data_size ]]
then
	mkdir -p "$target/$data_label"
	mount "$data_device" "$target/$data_label"
	! [[ $format_data ]] && h=$(fsck -N "$target/$data_label"|grep -o ' fsck.[^ ]*') && format_data=${h##*.}
fi	
df --sync -hlT -x tmpfs -x devtmpfs

## Copy
cp -a "$rofs"/* "$target"

## Prepare root
cat <<-END >"$target/etc/fstab"
	proc /proc proc defaults 0 0
	$swap_device $swap_label swap sw 0 0
	$root_device / $format_root relatime,errors=remount-ro 0 1
	UUID=$boot_uuid /boot $format_boot relatime 0 2
END
[[ $data_size ]] && echo "$data_device /$data_label $format_data relatime 0 2" >>"$target/etc/fstab"
echo "$crypt_label UUID=$crypt_uuid none luks" >"$target/etc/crypttab"
sed "s/mint/$hostname/g" /etc/hosts >"$target/etc/hosts"
sed "s/mint/$username/g" /etc/mdm/mdm.conf >"$target/etc/mdm/mdm.conf"
echo $hostname >"$target/etc/hostname"
echo "$LANG UTF-8" >>"$target/etc/locale.gen"
rm -- "$target/etc/resolv.conf"  ## remove symlink
cp /etc/resolv.conf "$target/etc"
cp "$self" "$target/root"
mount --bind /dev "$target/dev"
chroot "$target" "/root/$self" inside $username $grub_device $packages

Unmountall
echo -e "\n  Ready for reboot!\n"

exit 0
